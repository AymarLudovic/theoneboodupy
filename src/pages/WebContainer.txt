import React, { useState, useEffect, useRef } from 'react'; // Ajout de useRef
import { WebContainer, FileSystemTree } from '@webcontainer/api';

interface Message {
    text: string;
    isUser: boolean;
    isCode?: boolean;
    $id?: string; // ID du message dans Appwrite
}

interface CodeFile {
    filename: string;
    code: string;
}

interface WebContainerComponentProps {
    lastAIMessageWithCode: Message | null;
    setWebContainerURL: (url: string | null) => void;
    projectType: 'web' | 'mobile';
    extractCodeFiles: (text: string) => CodeFile[];
    onWebContainerStart: () => void;
    onWebContainerStop: () => void;
}

const WebContainerComponent: React.FC<WebContainerComponentProps> = ({
    lastAIMessageWithCode,
    setWebContainerURL,
    projectType,
    extractCodeFiles,
    onWebContainerStart,
    onWebContainerStop,
}) => {
    const [webContainer, setWebContainer] = useState<WebContainer | null>(null);
    const [internalWebContainerURL, setInternalWebContainerURL] = useState<string | null>(null);
    const [initialized, setInitialized] = useState(false);
    const [existingCodeFiles, setExistingCodeFiles] = useState<CodeFile[]>([]); // Nouveau state pour les fichiers existants
    const lastAIMessageWithCodeRef = useRef<Message | null>(null); //ref pour stocker la valeur précédente de lastAIMessageWithCode

    useEffect(() => {
        const initializeWebContainer = async () => {
            onWebContainerStart(); // Appeler le callback au début
            try {
                const wc = await WebContainer.boot();
                setWebContainer(wc);
                console.log('WebContainer started');
                setInitialized(true); // Marquer comme initialisé
            } catch (error) {
                console.error("Failed to boot WebContainer:", error);
            } finally {
                onWebContainerStop(); // Appeler le callback à la fin
            }
        };

        initializeWebContainer();

        return () => {
            if (webContainer) {
                //webContainer.dispose();
                console.log('WebContainer should dispose here (but is commented out)');
            }
        };
    }, []);

    // Fonction pour comparer deux tableaux de CodeFile
    const areFilesDifferent = (newFiles: CodeFile[], oldFiles: CodeFile[]): boolean => {
        if (newFiles.length !== oldFiles.length) {
            return true; // Nombre de fichiers différent
        }

        for (let i = 0; i < newFiles.length; i++) {
            if (newFiles[i].filename !== oldFiles[i].filename || newFiles[i].code !== oldFiles[i].code) {
                return true; // Fichier différent trouvé
            }
        }

        return false; // Tous les fichiers sont identiques
    };

    useEffect(() => {
        if (webContainer && initialized && lastAIMessageWithCode && lastAIMessageWithCode.isCode) {

            if (lastAIMessageWithCodeRef.current?.$id === lastAIMessageWithCode.$id) {
                console.log("Message has already been processed. Skipping.");
                return; // Skip processing if the message is the same
            }
           
            const codeFiles = extractCodeFiles(lastAIMessageWithCode.text);
            console.log('CodeFiles:', codeFiles);

            // Comparer les nouveaux fichiers avec les anciens
            const filesChanged = areFilesDifferent(codeFiles, existingCodeFiles);

            if (!filesChanged) {
                console.log("No file changes detected. Skipping WebContainer update.");
                return; // Skip the update if no files have changed
            }

            const packageJsonFile = codeFiles.find(file => file.filename === 'package.json');
            if (packageJsonFile) {
                console.log('package.json found:', packageJsonFile);
            } else {
                console.warn('package.json NOT found in codeFiles');
            }

            updateWebContainer(webContainer, codeFiles, projectType);
            setExistingCodeFiles(codeFiles); // Mettre à jour les fichiers existants
            lastAIMessageWithCodeRef.current = lastAIMessageWithCode;
        } else {
            console.log("No code available or WebContainer not ready.");
        }
    }, [lastAIMessageWithCode, webContainer, projectType, initialized, extractCodeFiles, existingCodeFiles]);

    const validateFilename = (filename: string): string => {
        let validatedFilename = filename.replace(/[^a-zA-Z0-9/.-]/g, '_');
        validatedFilename = validatedFilename.replace(/^_+|_+$/g, '');
        return validatedFilename;
    };

    const createFileSystemTree = (files: CodeFile[]): FileSystemTree => {
        const fileSystemTree: FileSystemTree = {};

        files.forEach(file => {
            const validatedFilename = validateFilename(file.filename);
            const fullPath = validatedFilename;
            const pathParts = fullPath.split('/');

            let currentLevel: any = fileSystemTree;
            for (let i = 0; i < pathParts.length; i++) {
                if (pathParts[i] === "") continue;
                const part = pathParts[i];

                // Correction importante : Remplace "_tabs_" par "(tabs)"
                const correctedPart = part === "_tabs_" ? "(tabs)" : part;

                if (i === pathParts.length - 1) {
                    currentLevel[correctedPart] = { file: { contents: file.code } };
                } else {
                    if (!currentLevel[correctedPart]) {
                        currentLevel[correctedPart] = { directory: {} };
                    }
                    currentLevel = currentLevel[correctedPart].directory;
                }
            }
        });

        return fileSystemTree;
    };

    const runCommand = async (webContainerInstance: WebContainer, command: string, args: string[]): Promise<number> => {
        const process = await webContainerInstance.spawn(command, args);
        process.output.pipeTo(new WritableStream({
            write(data) {
                console.log(`${command} ${args.join(' ')}: ${data}`);
            }
        }));
        return process.exit;
    };

    const updateWebContainer = async (webContainerInstance: WebContainer, codeFiles: CodeFile[], projectType: 'web' | 'mobile') => {
        onWebContainerStart();
        if (!webContainerInstance) {
            console.error("WebContainer not initialized");
            onWebContainerStop();
            return;
        }

        console.log("Project Type:", projectType);

        try {
            const fileSystemTree = createFileSystemTree(codeFiles);
            console.log('FileSystemTree:', fileSystemTree);

            await webContainerInstance.mount(fileSystemTree);

            // Ensure Node.js and npm are available
            console.log('Checking Node.js and npm...');
            const nodeCheckExitCode = await runCommand(webContainerInstance, 'node', ['-v']);
            if (nodeCheckExitCode !== 0) {
                console.error('Node.js not found. Installation may be required.');
                onWebContainerStop();
                return;
            }

            const npmCheckExitCode = await runCommand(webContainerInstance, 'npm', ['-v']);
            if (npmCheckExitCode !== 0) {
                console.error('npm not found. Installation may be required.');
                onWebContainerStop();
                return;
            }
            console.log('Node.js and npm are available.');

            if (fileSystemTree['package.json'] && 'file' in fileSystemTree['package.json']) {
                console.log('Installing dependencies...');
                const installProcess = await webContainerInstance.spawn('npm', ['install']);
                installProcess.output.pipeTo(new WritableStream({
                    write(data) {
                        console.log(data);
                    }
                }));
                const installExitCode = await installProcess.exit;
                if (installExitCode !== 0) {
                    console.error(`npm install failed with code ${installExitCode}`);
                    onWebContainerStop();
                    return;
                }
                console.log('Dependencies installed');
            } else {
                console.warn('No package.json found, skipping dependency installation.');
                onWebContainerStop();
                return;  // Important: Arrête si pas de package.json
            }

            let devCommand = 'run dev';

            const devServerProcess = await webContainerInstance.spawn('npm', devCommand.split(' '));
            devServerProcess.output.pipeTo(new WritableStream({
                write(data) {
                    console.log(data);
                }
            }));

            webContainerInstance.on('server-ready', (port, url) => {
                console.log(`Server ready on port ${port}, URL: ${url}`);
                setInternalWebContainerURL(url);
            });

        } catch (error: any) {
            console.error("Error updating WebContainers:", error);
            console.error("Detailed error:", error.message, error.stack);
        } finally {
            onWebContainerStop();
        }
    };

    useEffect(() => {
        if (internalWebContainerURL) {
            setWebContainerURL(internalWebContainerURL);
        }
    }, [internalWebContainerURL, setWebContainerURL]);

    return null;
};

export default WebContainerComponent;

